# -*- coding: utf-8 -*-
"""energy_planner.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c6pUo7DC4phE2v5nsiH7SBQq7649zo5u
"""

"""
Energy-Aware Route Planner â€” Notebook Module Version
"""

from typing import List, Tuple, Dict, Optional
import math

def build_consumption_array(route_length_km: float,
                            step_km: float,
                            baseline_consumption: float,
                            consumption_profile=None):
    n_steps = int(math.ceil(route_length_km / step_km)) + 1
    dist_km = [i * step_km for i in range(n_steps)]
    cons = [baseline_consumption for _ in dist_km]

    if consumption_profile:
        for (start_km, end_km, cons_val) in consumption_profile:
            start_idx = max(0, int(start_km / step_km))
            end_idx = min(n_steps - 1, int(end_km / step_km))
            for i in range(start_idx, end_idx + 1):
                cons[i] = cons_val

    return dist_km, cons


def plan_route(battery_kwh: float,
               baseline_consumption: float,
               route_length_km: float,
               step_km: float = 1.0,
               consumption_profile=None,
               stations=None,
               reserve_soc: float = 10.0,
               target_soc_at_stop: float = 80.0,
               regen_fraction: float = 0.0,
               charger_efficiency: float = 0.95):
    """
    Main EV Route Planner.
    Returns:
        - SOC timeline
        - Planned charging stops
        - Distance + consumption profiles
    """
    dist_km, cons_per_km = build_consumption_array(
        route_length_km, step_km, baseline_consumption, consumption_profile
    )

    if stations is None:
        stations = []

    stations_sorted = sorted(stations, key=lambda s: s[0])
    remaining_kwh = battery_kwh
    reserve_kwh = battery_kwh * (reserve_soc / 100.0)
    target_kwh = battery_kwh * (target_soc_at_stop / 100.0)

    soc_percent = []
    stops = []

    current_idx = 0
    n_steps = len(dist_km)

    while current_idx < n_steps - 1:
        # Try moving forward until reserve SOC prevents continuing
        for i in range(current_idx + 1, n_steps):
            eff_cons = cons_per_km[i] * (1 - regen_fraction)
            if remaining_kwh - eff_cons * step_km < reserve_kwh:
                break
            remaining_kwh -= eff_cons * step_km
            soc_percent.append((remaining_kwh / battery_kwh) * 100.0)
            current_idx = i

        if current_idx >= n_steps - 1:
            break  # reached end

        reachable_station = None
        # Find reachable charging stations
        for (km, power, name) in stations_sorted:
            station_idx = int(km / step_km)
            if station_idx <= current_idx:
                continue

            # energy needed to reach station
            needed = sum(cons_per_km[j] * (1 - regen_fraction) * step_km
                         for j in range(current_idx + 1, station_idx + 1))

            if remaining_kwh - needed >= reserve_kwh:
                reachable_station = (station_idx, km, power, name)
            else:
                break

        if reachable_station is None:
            break  # cannot continue, no station reachable

        # Move to station
        station_idx, station_km, station_power, station_name = reachable_station
        for j in range(current_idx + 1, station_idx + 1):
            remaining_kwh -= cons_per_km[j] * (1 - regen_fraction) * step_km
            remaining_kwh = max(remaining_kwh, 0.0)
            soc_percent.append((remaining_kwh / battery_kwh) * 100.0)

        before_soc = (remaining_kwh / battery_kwh) * 100.0

        # Compute charging needed
        if remaining_kwh < target_kwh:
            kwh_needed = (target_kwh - remaining_kwh) / charger_efficiency
            station_power = station_power if station_power > 0 else 50
            charge_time_h = kwh_needed / station_power
            remaining_kwh = min(battery_kwh, remaining_kwh + kwh_needed * charger_efficiency)
        else:
            kwh_needed = 0
            charge_time_h = 0

        after_soc = (remaining_kwh / battery_kwh) * 100.0

        stops.append({
            "loc_km": station_km,
            "station_name": station_name,
            "before_soc": round(before_soc, 2),
            "after_soc": round(after_soc, 2),
            "kwh_added": round(kwh_needed, 2),
            "charge_time_h": round(charge_time_h, 2)
        })

        current_idx = station_idx

    return {
        "dist_km": dist_km,
        "cons_kwh_per_km": cons_per_km,
        "soc_percent": soc_percent,
        "stops": stops
    }

example = plan_route(
    battery_kwh=60,
    baseline_consumption=0.15,
    route_length_km=500,
    consumption_profile=[
        (0, 50, 0.14),
        (50, 500, 0.16)
    ],
    stations=[
        (150, 120, "FastCharge A"),
        (200, 150, "FastCharge B"),
        (350, 60, "ChargePoint C")
    ],
    reserve_soc=10,
    target_soc_at_stop=80,
    regen_fraction=0.05
)

print("Planned Charging Stops:")
for s in example["stops"]:
    print(s)

print("\nFinal SOC:", example["soc_percent"][-1])

import matplotlib.pyplot as plt

dist = example["dist_km"]
soc = example["soc_percent"]

plt.figure(figsize=(10, 4))
plt.plot(dist[:len(soc)], soc, linewidth=2)

# Mark charge stops
for stop in example["stops"]:
    plt.axvline(stop["loc_km"], linestyle="--")
    plt.scatter(stop["loc_km"], stop["after_soc"], s=50)
    plt.text(stop["loc_km"]+2, stop["after_soc"]+2, stop["station_name"])

plt.xlabel("Distance (km)")
plt.ylabel("Battery (%)")
plt.title("Battery % vs Distance with Charging Stops")
plt.grid(True)
plt.show()

test = plan_route(
    battery_kwh=60,
    baseline_consumption=0.15,
    route_length_km=200,
    stations=[(100, 120, "TestStation")],
)

assert len(test["soc_percent"]) > 0
print("Test passed. SOC sample:", test["soc_percent"][:5])